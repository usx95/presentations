import { removeCodeRanges } from 'twoslash-protocol';

const defaultCompilerOptions = {
  strict: true,
  module: 99,
  target: 99,
  allowJs: true,
  skipDefaultLibCheck: true,
  skipLibCheck: true,
  moduleDetection: 3
};
const defaultHandbookOptions = {
  errors: [],
  noErrors: false,
  noErrorsCutted: false,
  noErrorValidation: false,
  noStaticSemanticInfo: false,
  showEmit: false,
  showEmittedFile: void 0,
  keepNotations: false
};

class TwoslashError extends Error {
  title;
  description;
  recommendation;
  code;
  constructor(title, description, recommendation, code) {
    let message = `
## ${title}

${description}
`;
    if (recommendation)
      message += `
${recommendation}`;
    if (code)
      message += `
${code}`;
    super(message);
    this.title = title;
    this.description = description;
    this.recommendation = recommendation;
    this.code = code;
  }
}

function serialize(n){if(typeof n=="string")return `'${n}'`;const i=new l$1;return i.dispatch(n),i.serialized}const l$1=/*@__PURE__*/function(){class n{serialized="";#t=new Map;write(t){this.serialized+=t;}dispatch(t){return this["$"+(t===null?"null":typeof t)].call(this,t)}compare(t,r){return typeof t=="string"&&typeof r=="string"?t.localeCompare(r):serialize(t).localeCompare(serialize(r))}objectEntries(t,r){const e=Array.from(r).sort((o,a)=>this.compare(o[0],a[0]));this.write(`${t}{`);for(let o=0;o<e.length;o++){const[a,s]=e[o];this.write(`${a}:`),this.dispatch(s),o<e.length-1&&this.write(",");}this.write("}");}$string(t){this.write("'"+t+"'");}$symbol(t){this.write(t.toString());}$bigint(t){this.write(`${t}n`);}$object(t){const r=Object.prototype.toString.call(t);let e="";const o=r.length;o<10?e="unknown:["+r+"]":e=r.slice(8,o-1);let a=null;if((a=this.#t.get(t))===void 0)this.#t.set(t,this.#t.size);else return this.write(`#${a}`);if(e!=="Object"&&e!=="Function"&&e!=="AsyncFunction"){const s=this["$"+e];if(s)s.call(this,t);else {if(typeof t?.entries=="function")return this.objectEntries(e,t.entries());throw new Error(`Cannot serialize ${e}`)}}else {const s=t.constructor.name,c=s==="Object"?"":s;return typeof t.toJSON=="function"?(c&&this.write(c),this.$object(t.toJSON())):this.objectEntries(c,Object.entries(t))}}$function(t){const r=Function.prototype.toString.call(t);if(r.slice(-15)==="[native code] }")return this.write(`${t.name||""}()[native]`);this.write(`${t.name}(${t.length})${r.replace(/\s*\n\s*/g,"")}`);}$Array(t){this.write("[");for(let r=0;r<t.length;r++)this.dispatch(t[r]),r<t.length-1&&this.write(",");this.write("]");}$Date(t){return this.write(`Date(${t.toJSON()})`)}$ArrayBuffer(t){this.write(`ArrayBuffer[${Array.prototype.slice.call(new Uint8Array(t)).join(",")}]`);}$Set(t){this.write("Set"),this.$Array(Array.from(t).sort((r,e)=>this.compare(r,e)));}$Map(t){return this.objectEntries("Map",t.entries())}}for(const i of ["boolean","number","null","undefined"])n.prototype["$"+i]=function(t){return this.write(t)};for(const i of ["Error","RegExp","URL"])n.prototype["$"+i]=function(t){return this.write(`${i}(${t.toString()})`)};for(const i of ["Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array"])n.prototype["$"+i]=function(t){this.write(`${i}[${Array.prototype.slice.call(t).join(",")}]`);};for(const i of ["BigInt64Array","BigUint64Array"])n.prototype["$"+i]=function(t){this.write(`${i}[${Array.prototype.slice.call(t).map(r=>`${r}n`).join(",")}]`);};return n}();

const z=[1779033703,-1150833019,1013904242,-1521486534,1359893119,-1694144372,528734635,1541459225],R=[1116352408,1899447441,-1245643825,-373957723,961987163,1508970993,-1841331548,-1424204075,-670586216,310598401,607225278,1426881987,1925078388,-2132889090,-1680079193,-1046744716,-459576895,-272742522,264347078,604807628,770255983,1249150122,1555081692,1996064986,-1740746414,-1473132947,-1341970488,-1084653625,-958395405,-710438585,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,-2117940946,-1838011259,-1564481375,-1474664885,-1035236496,-949202525,-778901479,-694614492,-200395387,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,-2067236844,-1933114872,-1866530822,-1538233109,-1090935817,-965641998],S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",r=[];class k{_data=new l;_hash=new l([...z]);_nDataBytes=0;_minBufferSize=0;finalize(e){e&&this._append(e);const s=this._nDataBytes*8,t=this._data.sigBytes*8;return this._data.words[t>>>5]|=128<<24-t%32,this._data.words[(t+64>>>9<<4)+14]=Math.floor(s/4294967296),this._data.words[(t+64>>>9<<4)+15]=s,this._data.sigBytes=this._data.words.length*4,this._process(),this._hash}_doProcessBlock(e,s){const t=this._hash.words;let i=t[0],o=t[1],a=t[2],c=t[3],h=t[4],g=t[5],f=t[6],y=t[7];for(let n=0;n<64;n++){if(n<16)r[n]=e[s+n]|0;else {const d=r[n-15],j=(d<<25|d>>>7)^(d<<14|d>>>18)^d>>>3,B=r[n-2],x=(B<<15|B>>>17)^(B<<13|B>>>19)^B>>>10;r[n]=j+r[n-7]+x+r[n-16];}const m=h&g^~h&f,p=i&o^i&a^o&a,u=(i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22),b=(h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25),w=y+b+m+R[n]+r[n],M=u+p;y=f,f=g,g=h,h=c+w|0,c=a,a=o,o=i,i=w+M|0;}t[0]=t[0]+i|0,t[1]=t[1]+o|0,t[2]=t[2]+a|0,t[3]=t[3]+c|0,t[4]=t[4]+h|0,t[5]=t[5]+g|0,t[6]=t[6]+f|0,t[7]=t[7]+y|0;}_append(e){typeof e=="string"&&(e=l.fromUtf8(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes;}_process(e){let s,t=this._data.sigBytes/64;e?t=Math.ceil(t):t=Math.max((t|0)-this._minBufferSize,0);const i=t*16,o=Math.min(i*4,this._data.sigBytes);if(i){for(let a=0;a<i;a+=16)this._doProcessBlock(this._data.words,a);s=this._data.words.splice(0,i),this._data.sigBytes-=o;}return new l(s,o)}}class l{words;sigBytes;constructor(e,s){e=this.words=e||[],this.sigBytes=s===void 0?e.length*4:s;}static fromUtf8(e){const s=unescape(encodeURIComponent(e)),t=s.length,i=[];for(let o=0;o<t;o++)i[o>>>2]|=(s.charCodeAt(o)&255)<<24-o%4*8;return new l(i,t)}toBase64(){const e=[];for(let s=0;s<this.sigBytes;s+=3){const t=this.words[s>>>2]>>>24-s%4*8&255,i=this.words[s+1>>>2]>>>24-(s+1)%4*8&255,o=this.words[s+2>>>2]>>>24-(s+2)%4*8&255,a=t<<16|i<<8|o;for(let c=0;c<4&&s*8+c*6<this.sigBytes*8;c++)e.push(S.charAt(a>>>6*(3-c)&63));}return e.join("")}concat(e){if(this.words[this.sigBytes>>>2]&=4294967295<<32-this.sigBytes%4*8,this.words.length=Math.ceil(this.sigBytes/4),this.sigBytes%4)for(let s=0;s<e.sigBytes;s++){const t=e.words[s>>>2]>>>24-s%4*8&255;this.words[this.sigBytes+s>>>2]|=t<<24-(this.sigBytes+s)%4*8;}else for(let s=0;s<e.sigBytes;s+=4)this.words[this.sigBytes+s>>>2]=e.words[s>>>2];this.sigBytes+=e.sigBytes;}}function digest(_){return new k().finalize(_).toBase64()}

function hash(input) {
  return digest(serialize(input));
}

const reConfigBoolean = /^\/\/\s?@(\w+)$/gm;
const reConfigValue = /^\/\/\s?@(\w+):\s?(.+)$/gm;
const reAnnonateMarkers = /^\s*\/\/\s*\^(\?|\||\^+)( .*)?$/gm;
const reCutBefore = /^[\t\v\f ]*\/\/\s?---cut(-before)?---\r?\n/gm;
const reCutAfter = /^[\t\v\f ]*\/\/\s?---cut-after---$/gm;
const reCutStart = /^[\t\v\f ]*\/\/\s?---cut-start---$/gm;
const reCutEnd = /^[\t\v\f ]*\/\/\s?---cut-end---\r?\n/gm;
const reFilenamesMakers = /^[\t\v\f ]*\/\/\s?@filename: (.+)$/gm;

function getObjectHash(obj) {
  return hash(obj);
}
function parsePrimitive(value, type) {
  if (typeof value === type)
    return value;
  switch (type) {
    case "number":
      return +value;
    case "string":
      return value;
    case "boolean":
      return value.toLowerCase() === "true" || value.length === 0;
  }
  throw new TwoslashError(
    `Unknown primitive value in compiler flag`,
    `The only recognized primitives are number, string and boolean. Got ${type} with ${value}.`,
    `This is likely a typo.`
  );
}
function typesToExtension(types) {
  const map = {
    js: "js",
    javascript: "js",
    ts: "ts",
    typescript: "ts",
    tsx: "tsx",
    jsx: "jsx",
    json: "json",
    jsn: "json",
    map: "json",
    mts: "ts",
    cts: "ts",
    mjs: "js",
    cjs: "js"
  };
  if (map[types])
    return map[types];
  throw new TwoslashError(
    `Unknown TypeScript extension given to Twoslash`,
    `Received ${types} but Twoslash only accepts: ${Object.keys(map)} `,
    ``
  );
}
function getIdentifierTextSpans(ts, sourceFile, fileOffset) {
  const textSpans = [];
  checkChildren(sourceFile);
  return textSpans;
  function checkChildren(node) {
    ts.forEachChild(node, (child) => {
      if (ts.isIdentifier(child)) {
        const text = child.getText(sourceFile);
        const start = child.getStart(sourceFile, false) + fileOffset;
        const end = start + text.length;
        textSpans.push([start, end, text]);
      }
      checkChildren(child);
    });
  }
}
function getOptionValueFromMap(name, key, optMap) {
  const result = optMap.get(key.toLowerCase());
  if (result === void 0) {
    const keys = Array.from(optMap.keys());
    throw new TwoslashError(
      `Invalid inline compiler value`,
      `Got ${key} for ${name} but it is not a supported value by the TS compiler.`,
      `Allowed values: ${keys.join(",")}`
    );
  }
  return result;
}
function splitFiles(code, defaultFileName, root) {
  const matches = Array.from(code.matchAll(reFilenamesMakers));
  const allFilenames = matches.map((match) => match[1].trimEnd());
  let currentFileName = allFilenames.includes(defaultFileName) ? "__index__.ts" : defaultFileName;
  const files = [];
  let index = 0;
  for (const match of matches) {
    const offset = match.index;
    const content = code.slice(index, offset);
    if (content) {
      files.push({
        offset: index,
        filename: currentFileName,
        filepath: root + currentFileName,
        content,
        extension: getExtension(currentFileName)
      });
    }
    currentFileName = match[1].trimEnd();
    index = offset;
  }
  if (index < code.length) {
    const content = code.slice(index);
    files.push({
      offset: index,
      filename: currentFileName,
      filepath: root + currentFileName,
      content,
      extension: getExtension(currentFileName)
    });
  }
  return files;
}
function getExtension(fileName) {
  return fileName.split(".").pop();
}
function parseFlag(name, value, start, end, customTags, tsOptionDeclarations) {
  if (customTags.includes(name)) {
    return {
      type: "tag",
      name,
      value,
      start,
      end
    };
  }
  const compilerDecl = tsOptionDeclarations.find((d) => d.name.toLocaleLowerCase() === name.toLocaleLowerCase());
  if (compilerDecl) {
    switch (compilerDecl.type) {
      case "number":
      case "string":
      case "boolean":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: parsePrimitive(value, compilerDecl.type),
          start,
          end
        };
      case "list": {
        const elementType = compilerDecl.element.type;
        const strings = value.split(",");
        const resolved = typeof elementType === "string" ? strings.map((v) => parsePrimitive(v, elementType)) : strings.map((v) => getOptionValueFromMap(compilerDecl.name, v, elementType));
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: resolved,
          start,
          end
        };
      }
      case "object":
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: JSON.parse(value),
          start,
          end
        };
      default: {
        return {
          type: "compilerOptions",
          name: compilerDecl.name,
          value: getOptionValueFromMap(compilerDecl.name, value, compilerDecl.type),
          start,
          end
        };
      }
    }
  }
  if (Object.keys(defaultHandbookOptions).includes(name)) {
    if (name === "errors" && typeof value === "string")
      value = value.split(" ").map(Number);
    if (name === "noErrors" && typeof value === "string") {
      if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      else
        value = value.split(" ").map(Number);
    }
    return {
      type: "handbookOptions",
      name,
      value,
      start,
      end
    };
  }
  return {
    type: "unknown",
    name,
    value,
    start,
    end
  };
}
function findFlagNotations(code, customTags, tsOptionDeclarations) {
  const flagNotations = [];
  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {
    const index = match.index;
    const name = match[1];
    flagNotations.push(
      parseFlag(name, true, index, index + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  Array.from(code.matchAll(reConfigValue)).forEach((match) => {
    const name = match[1];
    if (name === "filename")
      return;
    const index = match.index;
    const value = match[2];
    flagNotations.push(
      parseFlag(name, value, index, index + match[0].length + 1, customTags, tsOptionDeclarations)
    );
  });
  return flagNotations;
}
function findCutNotations(code, meta) {
  const removals = [];
  const cutBefore = [...code.matchAll(reCutBefore)];
  const cutAfter = [...code.matchAll(reCutAfter)];
  const cutStart = [...code.matchAll(reCutStart)];
  const cutEnd = [...code.matchAll(reCutEnd)];
  if (cutBefore.length) {
    const last = cutBefore[cutBefore.length - 1];
    removals.push([0, last.index + last[0].length]);
  }
  if (cutAfter.length) {
    const first = cutAfter[0];
    removals.push([first.index, code.length]);
  }
  if (cutStart.length !== cutEnd.length) {
    throw new TwoslashError(
      `Mismatched cut markers`,
      `You have ${cutStart.length} cut-starts and ${cutEnd.length} cut-ends`,
      `Make sure you have a matching pair for each.`
    );
  }
  for (let i = 0; i < cutStart.length; i++) {
    const start = cutStart[i];
    const end = cutEnd[i];
    if (start.index > end.index) {
      throw new TwoslashError(
        `Mismatched cut markers`,
        `You have a cut-start at ${start.index} which is after the cut-end at ${end.index}`,
        `Make sure you have a matching pair for each.`
      );
    }
    removals.push([start.index, end.index + end[0].length]);
  }
  if (meta)
    meta.removals.push(...removals);
  return removals;
}
function findQueryMarkers(code, meta, pc) {
  if (code.includes("//")) {
    const linesQuery = /* @__PURE__ */ new Set();
    Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {
      const type = match[1];
      const index = match.index;
      meta.removals.push([index, index + match[0].length + 1]);
      const markerIndex = match[0].indexOf("^");
      const pos = pc.indexToPos(index + markerIndex);
      let targetLine = pos.line - 1;
      while (linesQuery.has(targetLine) && targetLine >= 0)
        targetLine -= 1;
      const targetIndex = pc.posToIndex(targetLine, pos.character);
      if (type === "?") {
        meta.positionQueries.push(targetIndex);
      } else if (type === "|") {
        meta.positionCompletions.push(targetIndex);
      } else {
        const markerLength = match[0].lastIndexOf("^") - markerIndex + 1;
        meta.positionHighlights.push([
          targetIndex,
          targetIndex + markerLength,
          match[2]?.trim()
        ]);
      }
      linesQuery.add(pos.line);
    });
  }
  return meta;
}
function removeTsExtension(filename) {
  const sansMapOrDTS = filename.replace(/\.map$/, "").replace(/\.d\.ts$/, ".ts").replace(/\.map$/, "");
  return sansMapOrDTS.replace(/\.[^/.]+$/, "");
}

const flagKeys = [
  "all",
  "allowArbitraryExtensions",
  "allowImportingTsExtensions",
  "allowJs",
  "allowSyntheticDefaultImports",
  "allowUmdGlobalAccess",
  "allowUnreachableCode",
  "allowUnusedLabels",
  "alwaysStrict",
  "assumeChangesOnlyAffectDirectDependencies",
  "baseUrl",
  "build",
  "charset",
  "checkJs",
  "composite",
  "customConditions",
  "declaration",
  "declarationDir",
  "declarationMap",
  "diagnostics",
  "disableReferencedProjectLoad",
  "disableSizeLimit",
  "disableSolutionSearching",
  "disableSourceOfProjectReferenceRedirect",
  "downlevelIteration",
  "emitBOM",
  "emitDeclarationOnly",
  "emitDecoratorMetadata",
  "errors",
  "esModuleInterop",
  "exactOptionalPropertyTypes",
  "experimentalDecorators",
  "explainFiles",
  "extendedDiagnostics",
  "forceConsistentCasingInFileNames",
  "generateCpuProfile",
  "generateTrace",
  "help",
  "help",
  "ignoreDeprecations",
  "importHelpers",
  "importsNotUsedAsValues",
  "incremental",
  "init",
  "inlineSourceMap",
  "inlineSources",
  "isolatedModules",
  "jsx",
  "jsxFactory",
  "jsxFragmentFactory",
  "jsxImportSource",
  "keepNotations",
  "keyofStringsOnly",
  "lib",
  "listEmittedFiles",
  "listFiles",
  "listFilesOnly",
  "locale",
  "mapRoot",
  "maxNodeModuleJsDepth",
  "module",
  "moduleDetection",
  "moduleResolution",
  "moduleSuffixes",
  "newLine",
  "noEmit",
  "noEmitHelpers",
  "noEmitOnError",
  "noErrorTruncation",
  "noErrorValidation",
  "noErrors",
  "noErrorsCutted",
  "noFallthroughCasesInSwitch",
  "noImplicitAny",
  "noImplicitOverride",
  "noImplicitReturns",
  "noImplicitThis",
  "noImplicitUseStrict",
  "noLib",
  "noPropertyAccessFromIndexSignature",
  "noResolve",
  "noStaticSemanticInfo",
  "noStrictGenericChecks",
  "noUncheckedIndexedAccess",
  "noUnusedLocals",
  "noUnusedParameters",
  "out",
  "outDir",
  "outFile",
  "paths",
  "plugins",
  "preserveConstEnums",
  "preserveSymlinks",
  "preserveValueImports",
  "preserveWatchOutput",
  "pretty",
  "project",
  "reactNamespace",
  "removeComments",
  "resolveJsonModule",
  "resolvePackageJsonExports",
  "resolvePackageJsonImports",
  "rootDir",
  "rootDirs",
  "showConfig",
  "showEmit",
  "showEmittedFile",
  "skipDefaultLibCheck",
  "skipLibCheck",
  "sourceMap",
  "sourceRoot",
  "strict",
  "strictBindCallApply",
  "strictFunctionTypes",
  "strictNullChecks",
  "strictPropertyInitialization",
  "stripInternal",
  "suppressExcessPropertyErrors",
  "suppressImplicitAnyIndexErrors",
  "target",
  "traceResolution",
  "tsBuildInfoFile",
  "typeRoots",
  "types",
  "useDefineForClassFields",
  "useUnknownInCatchVariables",
  "verbatimModuleSyntax",
  "version",
  "watch"
];

function removeTwoslashNotations(code, customTags) {
  const meta = {
    removals: []
  };
  const tags = [
    ...customTags ?? [],
    ...flagKeys
  ];
  Array.from(code.matchAll(reConfigBoolean)).forEach((match) => {
    if (!tags.includes(match[1]))
      return;
    meta.removals.push([match.index, match.index + match[0].length + 1]);
  });
  Array.from(code.matchAll(reConfigValue)).forEach((match) => {
    if (!tags.includes(match[1]))
      return;
    meta.removals.push([match.index, match.index + match[0].length + 1]);
  });
  findCutNotations(code, meta);
  Array.from(code.matchAll(reAnnonateMarkers)).forEach((match) => {
    const index = match.index;
    meta.removals.push([index, index + match[0].length + 1]);
  });
  return removeCodeRanges(code, meta.removals).code;
}

export { TwoslashError as T, findFlagNotations as a, findQueryMarkers as b, defaultHandbookOptions as c, defaultCompilerOptions as d, removeTsExtension as e, findCutNotations as f, getObjectHash as g, getExtension as h, getIdentifierTextSpans as i, removeTwoslashNotations as r, splitFiles as s, typesToExtension as t };
